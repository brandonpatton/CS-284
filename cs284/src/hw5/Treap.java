package hw5;

//Brandon Patton
//I pledge my honor that I have abided by the Stevens Honor System.

import java.util.Random;
import java.util.Stack;

public class Treap<E extends Comparable<E>> {

	private static class Node<E>{
		//Data fields
		public E data;  // key for the search
		public int priority;  // random heap priority
		public Node<E> left;
		public Node<E> right;
		
		//Constructors
		public Node(E data, int priority) {
			if(data == null) {
				throw new NullPointerException("Error: Data cannot be null");
			}
			this.data = data;
			this.priority = priority;
		}
		
		/*
		 * Performs a right rotation, returning a reference to the root of the result 
		 * Updates the data and priority attributes and the left and right pointers of the involved
		 * nodes.
		 */
		Node<E> rotateRight(){
			 Node<E> l = this.left;
			 Node<E> r = l.right;
			 l.right = this;
			 this.left = r;
			 return l;
			 
		 }
		/*
		 *  Performs a left rotation returning a reference to the root of the result. 
		 *  Updates the attributes of the nodes.
		 */
		Node<E> rotateLeft(){
			 Node<E> r = this.right;
			 Node<E> l = r.left;
			 r.left = this;
			 this.right = l;
			 return r;
		 }
		 public String toString() {
	            return "(key="+this.data.toString()+", priority="+this.priority+")";
	        }
	}
	
	private Random priorityGenerator;
	private Node<E> root; 
	
	/*
	 * Creates empty Treap 
	 * Initializes priorityGenerator using new Random()
	 */
	public Treap() {
		this.root = null;
		this.priorityGenerator = new Random();
	}
	
	/*
	 * Creates empty Treap 
	 * Initializes priorityGenerator using new Random(seed). 
	 */
	public Treap(long seed) {
		this.root = null;
		this.priorityGenerator = new Random(seed);
	}
	
	
	/*
	 * All operation relating to add below:
	 * 
	 * Inserts the given element into the tree by creating a new node containing key as its
	 * data and a random priority generated by priorityGenerator
	 * 
	 * Returns true if a node with the key was successfully added to the treap.
	 * 
	 * If there is already a node containing the given key, the method returns false and does
	 * not modify the treap.
	 * 
	 */
	
	boolean add(E key) {
		if(find(key)) {
			return false;
		} else {
		return add(key, priorityGenerator.nextInt());
		}
	}
	
	boolean add(E key, int priority) {
		if (this.root == null) {
			this.root = new Node<E>(key, priority);
			return true;
		}
		if(find(key)){
			return false;
		}
		Stack<Node<E>> fill = new Stack<Node<E>>();
		Node<E> r = root;
		while (r != null) {
		fill.push(r);
			int compare = r.data.compareTo(key);
			if(compare > 0) {
				if(r.left == null) {
					r.left = new Node<E>(key, priority);
					reheap(fill, r.left);
					return true;
				} else {
					r = r.left;
				}
			} else {
				if(r.right == null) {
					r.right = new Node<E>(key, priority);
					reheap(fill, r.right);
					return true;
				} else {
					r = r.right;
				}
			}
	}
		return false;
	}
	
	/*
	 * reheap
	 * 
	 * Restores the heap invariant after performing the insertion.
	 */
	
	public void reheap(Stack<Node<E>> fill, Node<E> current) {
        while (!fill.isEmpty()) {
            Node<E> parent = fill.pop();
            if (parent.priority < current.priority){
                if (parent.data.compareTo(current.data) > 0)
                    current = parent.rotateRight();
                else
                    current = parent.rotateLeft();
                // fix grandparents link
                if (!fill.isEmpty())
                    if (fill.peek().left == parent)
                        fill.peek().left = current;
                    else
                        fill.peek().right = current;
                else
                    this.root = current;
            } else
                break;
        }
    }
	
	/*
	 * All operations relating to delete below:
	 * 
	 * Deletes the node with the given key from the treap and returns true.
	 * 
	 * If the key was not found, the method does not modify the treap and returns false.
	 * 
	 */
	private Node<E> deletehelper(Node<E> current, E key){
        if (current == null)
            return current;
        if(key.compareTo(current.data) < 0){
            current.left = deletehelper(current.left, key);
        }  
        else if (current.left == null){
            Node<E> temp = current.right;
            current = temp;
        }
        
        else if (current.right == null){
            Node<E> temp = current.left;
            current = temp;
        } 
        else if (key.compareTo(current.data) > 0){
            current.right = deletehelper(current.right, key);
        } 
        else if (current.left.priority < current.right.priority){
            current = current.rotateLeft();
            current.left = deletehelper(current.left, key);
        } 
        else {
            current = current.rotateRight();
            current.right = deletehelper(current.right, key);
        }
        return current;
    }
 
    /**
     * deletes a given key from the treap
     * @param key key to delete from treap
     * @return true if successful
     */
    public boolean delete(E key){
        if(root == null) {
        	return false;
        }
        if(find(key)==false) {
            return false;
        }
        this.root = deletehelper(this.root, key);
        return true;
    }
	
    
    /*
     * find(Node<E> root, E key)
     * 
     * Finds a node with the given key in the treap rooted at root and returns true if it finds 
     * it and false otherwise.
     */
    private boolean find(Node<E> root, E key) {
		while(root != null) {
			if (key == root.data) {
				return true;
			}
			else if (key.compareTo(root.data) < 0) {
				root = root.left;
			}
			else {
				root = root.right;
			}
		}
		return false;
	}
    
    /*
     * find(E key)
     * 
     *  Finds a node with the given key in the treap and returns true if it finds it and false otherwise.
     */
	public boolean find(E key) {
		return find(root,key);
	}
	
	public void preOrderTraverse(Node<E> n, int d, StringBuilder string) {
		for (int i = 1; i < d; i++) {
            string.append("  ");
        }

        if (n == null) {
            string.append("null\n");
        } else {
            string.append(n.toString());
            string.append("\n");
            preOrderTraverse(n.left, d + 1, string);
            preOrderTraverse(n.right, d + 1, string);

        }
		
	}
	public String toString() {
		StringBuilder string = new StringBuilder();
        preOrderTraverse(root, 1, string);
        return string.toString();

	}
	public static void main (String[] args) {

	}

	
}

